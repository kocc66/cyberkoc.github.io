<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Two-Player Chess with Rules</title>
    <style>
        body {
            display: flex;
            flex-direction: column;
            align-items: center;
            justify-content: center;
            height: 100vh;
            margin: 0;
            font-family: Arial, sans-serif;
        }

        h1 {
            margin-bottom: 20px;
            font-size: 24px;
        }

        #chessboard {
            display: grid;
            grid-template-columns: repeat(8, 1fr);
            grid-template-rows: repeat(8, 1fr);
            width: 90vw;
            height: 90vw;
            max-width: 600px;
            max-height: 600px;
        }

        .square {
            width: 100%;
            height: 100%;
            display: flex;
            justify-content: center;
            align-items: center;
            font-size: 24px;
            user-select: none;
        }

        .black {
            background-color: #769656;
        }

        .white {
            background-color: #eeeed2;
        }

        .selected {
            border: 3px solid yellow;
        }
    </style>
</head>
<body>

<h1>Two-Player Chess</h1>
<div id="chessboard"></div>

<script>
    const initialBoard = [
        ['♜', '♞', '♝', '♛', '♚', '♝', '♞', '♜'],
        ['♟', '♟', '♟', '♟', '♟', '♟', '♟', '♟'],
        ['', '', '', '', '', '', '', ''],
        ['', '', '', '', '', '', '', ''],
        ['', '', '', '', '', '', '', ''],
        ['', '', '', '', '', '', '', ''],
        ['♙', '♙', '♙', '♙', '♙', '♙', '♙', '♙'],
        ['♖', '♘', '♗', '♕', '♔', '♗', '♘', '♖']
    ];

    let chessboard = document.getElementById('chessboard');
    let selectedPiece = null;
    let selectedPosition = null;
    let turn = 'white'; // Oyuncu sırası

    function createBoard() {
        for (let row = 0; row < 8; row++) {
            for (let col = 0; col < 8; col++) {
                let square = document.createElement('div');
                square.classList.add('square');
                square.classList.add((row + col) % 2 === 0 ? 'white' : 'black');
                square.id = `${row}-${col}`;
                square.textContent = initialBoard[row][col];
                square.addEventListener('click', () => selectSquare(row, col));
                chessboard.appendChild(square);
            }
        }
    }

    function selectSquare(row, col) {
        let selectedSquare = document.getElementById(`${row}-${col}`);

        if (selectedPiece) {
            if (isValidMove(selectedPosition, [row, col], selectedPiece)) {
                movePiece(selectedPosition, [row, col]);
                turn = (turn === 'white') ? 'black' : 'white';
            }
            selectedPiece = null;
            selectedPosition = null;
            clearSelection();
        } else {
            if ((turn === 'white' && isWhitePiece(initialBoard[row][col])) || 
                (turn === 'black' && isBlackPiece(initialBoard[row][col]))) {
                selectedPiece = initialBoard[row][col];
                selectedPosition = [row, col];
                selectedSquare.classList.add('selected');
            }
        }
    }

    function isValidMove(from, to, piece) {
        const [fromRow, fromCol] = from;
        const [toRow, toCol] = to;
        const targetPiece = initialBoard[toRow][toCol];

        // Her taşın hareket kuralları
        if (piece === '♙') return isValidPawnMove(from, to, targetPiece, 'white');
        if (piece === '♟') return isValidPawnMove(from, to, targetPiece, 'black');
        if (piece === '♖' || piece === '♜') return isValidRookMove(from, to);
        if (piece === '♘' || piece === '♞') return isValidKnightMove(from, to);
        if (piece === '♗' || piece === '♝') return isValidBishopMove(from, to);
        if (piece === '♕' || piece === '♛') return isValidQueenMove(from, to);
        if (piece === '♔' || piece === '♚') return isValidKingMove(from, to);

        return false;
    }

    function isValidPawnMove(from, to, targetPiece, color) {
        const [fromRow, fromCol] = from;
        const [toRow, toCol] = to;
        const direction = color === 'white' ? -1 : 1;
        const startingRow = color === 'white' ? 6 : 1;
        const isEnemyPiece = color === 'white' ? isBlackPiece(targetPiece) : isWhitePiece(targetPiece);

        // Normal hareket
        if (fromCol === toCol && !targetPiece) {
            if (toRow === fromRow + direction) return true;
            if (toRow === fromRow + 2 * direction && fromRow === startingRow && !initialBoard[toRow - direction][fromCol]) return true;
        }

        // Diagonal vurma
        if (Math.abs(fromCol - toCol) === 1 && toRow === fromRow + direction && isEnemyPiece) {
            return true;
        }

        return false;
    }

    function isValidRookMove(from, to) {
        return isStraightMove(from, to) && isPathClear(from, to);
    }

    function isValidKnightMove(from, to) {
        const [fromRow, fromCol] = from;
        const [toRow, toCol] = to;
        const rowDiff = Math.abs(fromRow - toRow);
        const colDiff = Math.abs(fromCol - toCol);
        return (rowDiff === 2 && colDiff === 1) || (rowDiff === 1 && colDiff === 2);
    }

    function isValidBishopMove(from, to) {
        return isDiagonalMove(from, to) && isPathClear(from, to);
    }

    function isValidQueenMove(from, to) {
        return (isStraightMove(from, to) || isDiagonalMove(from, to)) && isPathClear(from, to);
    }

    function isValidKingMove(from, to) {
        const [fromRow, fromCol] = from;
        const [toRow, toCol] = to;
        const rowDiff = Math.abs(fromRow - toRow);
        const colDiff = Math.abs(fromCol - toCol);
        return rowDiff <= 1 && colDiff <= 1;
    }

    function isStraightMove(from, to) {
        const [fromRow, fromCol] = from;
        const [toRow, toCol] = to;
        return fromRow === toRow || fromCol === toCol;
    }

    function isDiagonalMove(from, to) {
        const [fromRow, fromCol] = from;
        const [toRow, toCol] = to;
        return Math.abs(fromRow - toRow) === Math.abs(fromCol - toCol);
    }

    function isPathClear(from, to) {
        const [fromRow, fromCol] = from;
        const [toRow, toCol] = to;

        const rowStep = Math.sign(toRow - fromRow);
        const colStep = Math.sign(toCol - fromCol);

        let currentRow = fromRow + rowStep;
        let currentCol = fromCol + colStep;

        while (currentRow !== toRow || currentCol !== toCol) {
            if (initialBoard[currentRow][currentCol] !== '') return false;
            currentRow += rowStep;
            currentCol += colStep;
        }

        return true;
    }

    function movePiece(from, to) {
        const [fromRow, fromCol] = from;
        const [toRow, toCol] = to;
        initialBoard[toRow][toCol] = initialBoard[fromRow][fromCol];
        initialBoard[fromRow][fromCol] = '';
        updateBoard();
    }

    function isWhitePiece(piece) {
        return ['♖', '♘', '♗', '♕', '♔', '♙'].includes(piece);